<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
    <style>
/* <<<<<<< Updated upstream
      #map { height: 500px; width: 100%; }

      .alert {
        padding: 20px;
        background-color: #f44336;
        color: white;
      }

      .closebtn {
        margin-left: 15px;
        color: white;
        font-weight: bold;
        float: right;
        font-size: 22px;
        line-height: 20px;
        cursor: pointer;
        transition: 0.3s;
      }

      .closebtn:hover {
        color: black;
      }
    </style>
  </head>
  <body>
    <div id="revealid">
      <button style="display: block; font-size: 200px;" onclick="reveal()">CLICK TO SEE THE RESULTS</button>
    </div>

    {% load static %}
    <div class="alert" id="alert1" style="text-align: center; display: none">
    </div>
    <a href="{% url 'home' %}">Home</a>
    Evil
    <div id="map"></div>
======= */
        #map { height: 500px; width: 85%; }
        .center {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }
        #evilText{
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #homeButton {
            background-color: rgb(150, 2, 2);
            font-size: 40px;
            font-family: Georgia, 'Times New Roman', Times, serif;
            color: white;
            height: 50px;
            width: 240px;
            margin-top: 5px;
            margin-bottom: 0px;
            border-radius: 5px;
            transition: all 1s ease-in-out;
        }
        #homeButton:hover {
          transform: scale(0.05);
        }
        .fire {
          height: auto; 
          width: auto; 
          margin-left: 50px;
          margin-right: 50px;
          max-width: 140px; 
          max-height: 140px;
        }
    </style>
  </head>
  <body onload="route('longest')" style="background-image: url(https://i0.wp.com/racinecountyeye.com/wp-content/uploads/2023/04/pexels-photo-2726986.jpeg);">
    <div>
        <a href="{% url 'home' %}"><button  id="homeButton">Home</button></a>
    </div>
    <div id="revealid">
        <button style="display: block; font-size: 200px;" onclick="reveal()">CLICK TO SEE THE RESULTS</button>
    </div>
      {% load static %}
      <div class="alert" id="alert1" style="text-align: center; display: none">
      </div>
    <div id="evilText">
        <img class="fire" src="https://img.freepik.com/free-psd/fiery-blaze-vivid-image-intense-combustion_191095-78116.jpg?semt=ais_hybrid&w=740" alt="fire">
        <p style="font-size: 100px; margin-top: 0px; margin-bottom: 0px; font-family: Georgia, 'Times New Roman', Times, serif; color: rgb(255, 0, 0);">EVIL!!!</p>
        <img class="fire" src="https://img.freepik.com/free-psd/fiery-blaze-vivid-image-intense-combustion_191095-78116.jpg?semt=ais_hybrid&w=740" alt="fire">
    </div>
    <div class="center">
        <div id="map" style="margin-top: 10px;"></div>
    </div>
<!-- >>>>>>> Stashed changes -->
    <script>
      bool_switch = false

      function reveal() {
        document.getElementById("revealid").style.display = "none";
        route('longest')
      }

      function playAudio() {
        myAudio.play();
      }

      function displayAlert(alertId) {
        document.getElementById(alertId).style.display = "none";
        var div = document.getElementById(alertId)
        var image_array = [`<img src="{% static 'images/crash.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/deer.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/drift.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/lit.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/shot.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/small.jpg' %}" width="250" height="300">`,
                             `<img src="{% static 'images/wind.jpg' %}" width="250" height="300">`,
                            ]
        var randomImageIndex = Math.floor(Math.random() * image_array.length);
        var audio_array = [`<audio id="myAudio" src="{% static 'audios/exitNow.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/exitHere.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/highWindAdvisory.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/sppedCheck.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/wildFire.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/crashRep.mp3' %}"></audio>`,
                           `<audio id="myAudio" src="{% static 'audios/deerCrossing.mp3' %}"></audio>`,

                            ]
        var randomAudioIndex = Math.floor(Math.random() * audio_array.length);
        div.innerHTML = audio_array[randomAudioIndex] + image_array[randomImageIndex]
        myAudio.play();
      }

      function hideAlert(alertId) {
        document.getElementById(alertId).style.display = "block";
      }

      function startNotifications() {
        if (bool_switch) {
          displayAlert("alert1")
        } else {
          hideAlert("alert1")
        }
        bool_switch = !bool_switch
      }

      var map = L.map('map').setView([0, 0], 2);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(map);

      var startMarker, endMarker, routeLayer;

      function getLocation() {
          return new Promise((resolve, reject) => {
              if (navigator.geolocation) {
                  navigator.geolocation.getCurrentPosition(position => {
                      resolve([position.coords.latitude, position.coords.longitude]);
                  }, error => {
                      reject(error);
                  });
              } else {
                  reject("Geolocation is not supported by this browser.");
              }
          });
      }

      async function route(type) {
          setInterval(startNotifications, 5000);
          var startInput = localStorage["startInput"];
          var endInput = localStorage["endInput"];

          let startCoords;
          if (startInput) {
              startCoords = await geocode(startInput);
              if (!startCoords) {
                  alert("Could not geocode start location");
                  return;
              }
          } else {
              try {
                  startCoords = await getLocation();
              } catch (error) {
                  alert("Unable to get current location: " + error);
                  return;
              }
          }

          const endCoords = await geocode(endInput);
          if (!endCoords) {
              alert("Could not geocode end location.");
              return;
          }
        //   a
          var startLat = startCoords[0];
          var startLng = startCoords[1];
          var endLat = endCoords[0];
          var endLng = endCoords[1];

          var osrmUrl = `https://router.project-osrm.org/route/v1/driving/${startLng},${startLat};${endLng},${endLat}?overview=full&geometries=geojson`;

          fetch(osrmUrl)
              .then(response => response.json())
              .then(data => {
                  if (data.routes && data.routes.length > 0) {
                      var routeData = data.routes[0];
                      var geometry = L.geoJSON(routeData.geometry);

                      if (routeLayer) {
                          map.removeLayer(routeLayer);
                      }
                      routeLayer = geometry.addTo(map);

                      var bounds = geometry.getBounds();
                      map.fitBounds(bounds);

                      if (startMarker) {
                          map.removeLayer(startMarker);
                      }
                      startMarker = L.marker([startLat, startLng]).addTo(map);

                      if (endMarker) {
                          map.removeLayer(endMarker);
                      }
                      endMarker = L.marker([endLat, endLng]).addTo(map);

                      var instructions = "";
                      if (routeData.legs && routeData.legs.length > 0) {
                          routeData.legs[0].steps.forEach(step => {
                              instructions += step.maneuver.instruction + "<br>";
                          });
                      }

                      if (type === 'longest') {
                          calculateLongestRoute(startCoords, endCoords, routeData.distance);
                      }

                  } else {
                      alert("No route found.");
                  }
              })
              .catch(error => {
                  console.error("Error fetching route:", error);
                  alert("Error fetching route.");
              });
      }

      async function geocode(address) {
          const url = `https://nominatim.openstreetmap.org/search?q=${encodeURIComponent(address)}&format=json`;
          try {
              const response = await fetch(url);
              const data = await response.json();
              if (data && data.length > 0) {
                  return [parseFloat(data[0].lat), parseFloat(data[0].lon)];
              } else {
                  return null;
              }
          } catch (error) {
              console.error("Geocoding error:", error);
              return null;
          }
      }

      async function calculateLongestRoute(startCoords, endCoords, fastestDistance) {
          const minMultiplier = 2; // Only minimum is 2x
          const maxMultiplier = 100; // Large max for flexibility
          const targetDistance = fastestDistance * (Math.random() * (maxMultiplier - minMultiplier) + minMultiplier);

          async function routeWithWaypoints(waypoints) {
              let coordsString = `${startCoords[1]},${startCoords[0]};`;
              waypoints.forEach(waypoint => {
                  coordsString += `${waypoint[1]},${waypoint[0]};`;
              });
              coordsString += `${endCoords[1]},${endCoords[0]}`;

              const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${coordsString}?overview=full&geometries=geojson`;

              const response = await fetch(osrmUrl);
              const data = await response.json();

              if (data.routes && data.routes.length > 0) {
                  return data.routes[0];
              }
              return null;
          }

          function generateWaypoints(start, end, numWaypoints) {
              const waypoints = [];
              const latDiff = end[0] - start[0];
              const lngDiff = end[1] - start[1];
              const maxDeviation = 0.5; // Increased deviation

              for (let i = 0; i < numWaypoints; i++) {
                  const lat = start[0] + latDiff * Math.random();
                  const lng = start[1] + lngDiff * Math.random();

                  const deviationLat = (Math.random() - 0.5) * maxDeviation * Math.abs(latDiff);
                  const deviationLng = (Math.random() - 0.5) * maxDeviation * Math.abs(lngDiff);

                  waypoints.push([lat + deviationLat, lng + deviationLng]);
              }
              return waypoints;
          }

          function isRouteValid(routeGeometry) {
              return routeGeometry.coordinates.length > 5;
          }

          let attempts = 0;
          while (attempts < 10) {
              const numWaypoints = Math.floor(Math.random() * 5) + 2;
              const waypoints = generateWaypoints(startCoords, endCoords, numWaypoints);
              const route = await routeWithWaypoints(waypoints);

              if (route && route.distance >= fastestDistance * minMultiplier && isRouteValid(route.geometry)) { //only check minimum.
                  const geometry = L.geoJSON(route.geometry);
                  if (routeLayer) {
                      map.removeLayer(routeLayer);
                  }
                  routeLayer = geometry.addTo(map);

                  const bounds = geometry.getBounds();
                  map.fitBounds(bounds);

                  let instructions = "";
                  if (route.legs && route.legs.length > 0) {
                      route.legs.forEach(leg=>{
                        leg.steps.forEach(step => {
                          instructions += step.maneuver.instruction + "<br>";
                        });
                      });
                  }
                  return;
              }
              attempts++;
          }
          alert("Could not find a longer route within the specified distance range.");
      }
    </script>
  </body>
</html>